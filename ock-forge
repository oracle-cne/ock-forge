#! /bin/bash
#
# Copyright (c) 2024, Oracle and/or its affiliates.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.
set -e

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

DEVICE=
DISK=
FILESYSTEM=xfs
IMAGE=
CONFIG_DIR=
CONFIGS_DIR=
OSTREE_IMAGE_PATH=
CLEAN=yes
PARTITION=
SOURCE=
BRANCH=
IGNITION=
IGNITION_PROVIDER=
KARGS=()

OS_NAME=ock

BUILD_IMAGE=ock-builder:latest

usage() {
	cat << EOF
ock-forge [options] -d *device* (-i *ostree-image* | -C *directory* -c *directory*)

 -d | --device *block-device*

  The path to an existing block device.  This device is the installation target.
  All operations performed by the image builder are executed against this
  device.

 -D | --disk *image-path*

  The path to a disk image file.  This values is only necessary if the
  installation target is actually a file rather than a raw device.  This file
  is attached to the device specified with -d.

 -f | --filesystem *filesystem*

  The filesystem to use when formatting the root partition.  Only xfs is
  supported.

 -i | --image *container-image*

  A fully qualified container image name, including a tag.  This argument is
  used in multiple ways.  If given alone, this container image is used as the
  base image to deploy the OS.  In this case, building the ostree is skipped
  entirely.  If given with -c as well as -O, it is used to generate an ostree
  container image that can be used for later installations or upgrades.

 -s | --source *URI*

  The URI of an OCK configuration.  The configuration is copied from this
  location into the value of the '-C' argument. If the URI ends with '.git',
  the assumption is that it refers to a Git repository.  Otherwise, the URI
  is assumed to refer to a directory on the local filesystem.  If this option
  is omitted, the existing configuration is used.

 -b | --branch *branch*

  If '-s' refers to a Git repository, clone this branch.  Without this option
  the default branch is cloned.

 -C | --configs-dir *path*

  A directory containing a set of rpm-ostree configurations.

 -c | --config-dir *path*

  A directory containing the rpm-ostree configuration to build.  This must be
  a subdirectory of '--configs-dir', at whatever depth is required to ensure
  that all symlinks can be resolved.  If this option is specified, a complete
  rpm-ostree build is performed and optionally packaged into an OCI (Open
  Container Initiative) archive.

 -o | --os-name *name*

  The name of the ostree deployment.

 -O | --ostree-image-path *path*

  The path to write the OCI (Open Container Initiative) archive generated by the
  installation process.  If this value is not specified, no archive is generated.
  If -c is not provided, this option is ignored.  If -i is provided and points
  to a valid ostree container image, it is used as the reference for generating
  a chunked image.

 -n | --no-clean

  If this option is provided, do not perform any post-install cleanup steps like
  unmounting partitions or detaching virtual block devices.

 -P | --partition

  If this option is provided, the block device specified by -d will have its
  partition table wiped and repopulated with the default geometry.

 -p | --provider *ignition-provider*

  Set the ignition provider.  The default value is 'qemu'.  If -I is used to
  embed an ignition file, the default value is 'file'.

 -I | --ignition *path*

  The path to an ignition file.  This file is embeded into the initramfs on
  the deployment.  If -p is not given, the ignition provider is set to 'file'.

 -B | --build-image *container-image*

  The name of a container image to use when building the OCK boot media.  The
  default value is 'ock-builder:latest'.

 --karg *argument*
 --karg-append *argument*
 --karg-delete *argument*

  Arguments passed to `ostree`.  Refer to `ostree admin deploy --help` for
  usage.  Used to control kernel arguments.

 -h | --help

  Print this message.
EOF
}

while true; do
	case "$1" in
	"") break;;
	-d | --device ) DEVICE="$2"; shift; shift ;;
	-D | --disk ) DISK="$2"; shift; shift ;;
	-f | --filesystem ) FILESYSTEM="$2"; shift; shift ;;
	-s | --source ) SOURCE="$2"; shift; shift; ;;
	-b | --branch ) BRANCH="$2"; shift; shift ;;
	-i | --image ) IMAGE="$2"; shift; shift ;;
	-c | --config-dir ) CONFIG_DIR="$2"; shift; shift ;;
	-C | --configs-dir ) CONFIGS_DIR="$2"; shift; shift ;;
	-o | --os-name ) OS_NAME="$2"; shift; shift ;;
	-n | --no-clean ) CLEAN=; shift; shift ;;
	-O | --ostree-image-path ) OSTREE_IMAGE_PATH="$2"; shift; shift ;;
	-p | --provider) IGNITION_PROVIDER="$2"; shift; shift ;;
	-P | --partition ) PARTITION=yes; shift ;;
	-B | --build-image ) BUILD_IMAGE="$2"; shift; shift ;;
	-I | --ignition ) IGNITION="$2"; shift; shift ;;
	-h | --help ) usage; exit 0 ;;
	--karg | --karg-append | --karg-delete ) KARGS+=("$1" "$2"); shift; shift ;;
	esac
done

if [[ -z "$DEVICE" ]]; then
	echo "A device is required"
	exit 1
fi

if [[ -z "$FILESYSTEM" ]]; then
	echo "A filesystem is required"
	exit 1
fi

if [[ -z "$IMAGE" && -z "$CONFIG_DIR" ]]; then
	echo "A container image or treefile is required"
	exit 1
fi

set -x

if [[ -z "$IGNITION_PROVIDER" ]]; then
	if [[ -z "$IGNITION" ]]; then
		IGNITION_PROVIDER=qemu
	else
		IGNITION_PROVIDER=file
	fi
fi

# Fully qualify all paths so it is possible to change directory
if [[ -n "$DISK" ]]; then
	DISK=$(realpath -m "$DISK")
fi
if [[ -n "$CONFIGS_DIR" ]]; then
	CONFIGS_DIR=$(realpath -m "$CONFIGS_DIR")
fi
if [[ -n "$OSTREE_IMAGE_PATH" ]]; then
	OSTREE_IMAGE_PATH=$(realpath -m "$OSTREE_IMAGE_PATH")
fi
if [[ -n "$IGNITION" ]]; then
	IGNITION=$(realpath "$IGNITION")
fi


# Run this before the pushd so that SOURCE does not have to be dereferenced.
# This makes it easier to account for non-filesystem sources like Git repos.
if [[ -n "$SOURCE" ]]; then
	${SCRIPT_DIR}/copy-source.sh -s "$SOURCE" -t "$CONFIGS_DIR" -b "$BRANCH"
fi

pushd "$SCRIPT_DIR"

TMPDIR=$(realpath $(mktemp -d))

OSTREE_IMAGE_DIR=
OSTREE_IMAGE_NAME=
OSTREE_IMAGE_ARG=
if [[ -n "$OSTREE_IMAGE_PATH" ]]; then
	OSTREE_IMAGE_DIR=$(dirname "$OSTREE_IMAGE_PATH")
	OSTREE_IMAGE_NAME=$(basename "$OSTREE_IMAGE_PATH")
	OSTREE_IMAGE_ARG="-O $OSTREE_IMAGE_NAME"
fi

# If the builder container image does not exist, build it.
if ! podman image exists "$BUILD_IMAGE"; then
	if ! podman pull "$BUILD_IMAGE"; then
		if [ ! -f build-image/rpm-ostree-2024.3-4.el9.$(uname -m).rpm ]; then
			./build-rpmostree.sh ./build-image
		fi
		pushd build-image
		podman build --build-arg ARCH=$(uname -m) -t "$BUILD_IMAGE" .
		popd
	fi
fi

# If a disk is passed in and that disk is a qcow image,
# create the disk and attached to an nbd.  If it's an iso,
# set up a loopback device.
if [[ "$DISK" =~ ".qcow" ]]; then
	./setup-vm-disk.sh -d "$DEVICE" -D "$DISK"

	if [[ -n "$SUDO_UID" && -n "$SUDO_GID" ]]; then
		chown "${SUDO_UID}:${SUDO_GID}" "$DISK"
	fi
elif [[ "$DISK" =~ ".iso" ]]; then
	truncate --size=15G "$DISK"

	# loopback devices must be partitioned as files
	# before attaching them via the loopback driver.
	# Do that now, then unset the partition flag so
	# that it's not partitioned later
	if [[ -n "$PARTITION" ]]; then
		./make-partitions.sh -d "$DISK" -f "$FILESYSTEM"
		PARTITION=""
	fi

	losetup -P "$DEVICE" "$DISK"

	if [[ -n "$SUDO_UID" && -n "$SUDO_GID" ]]; then
		chown "${SUDO_UID}:${SUDO_GID}" "$DISK"
	fi
fi

# If desired, lay down the partition table
if [[ -n "$PARTITION" ]]; then
	./make-partitions.sh -d "$DEVICE" -f "$FILESYSTEM"
fi

OSTREE_IMAGE_VOL=
if [ -n "$OSTREE_IMAGE_DIR" ]; then
	OSTREE_IMAGE_VOL="-v $OSTREE_IMAGE_DIR:/out"
fi

CONFIGS_DIR_VOL=
CONFIG_DIR_ARG=
if [ -n "$CONFIGS_DIR" ]; then
	CONFIGS_DIR_VOL="-v $CONFIGS_DIR:/configs"
	CONFIG_DIR_ARG="-c /configs/$CONFIG_DIR"
fi

IGNITION_VOL=
IGNITION_ARG=
if [ -n "$IGNITION" ]; then
	IGNITION_VOL="-v $IGNITION:/etc/config.ign"
	IGNITION_ARG="-I /etc/config.ign"
fi

# Install the OS and generate an ostree image with the same contents
podman run --privileged -ti --rm \
	--mount type=bind,source="${TMPDIR}",target=/var/tmp,relabel=shared \
	$OSTREE_IMAGE_VOL \
	$IGNITION_VOL \
	$CONFIGS_DIR_VOL \
	"$BUILD_IMAGE" \
	-d "$DEVICE" -F \
	-m /mnt \
	-f "$FILESYSTEM" \
	-i "$IMAGE" \
	$CONFIG_DIR_ARG \
	$IGNITION_ARG \
	$OSTREE_IMAGE_ARG \
	"${KARGS[@]}" \
	-o "$OS_NAME" \
	-p "$IGNITION_PROVIDER"

# If an archive of an ostree container image was desired, unpack
# it into the local image cache.
if [[ -n "$OSTREE_IMAGE_PATH" ]]; then
	gunzip -c "$OSTREE_IMAGE_PATH" | podman load
	rm -f "$OSTREE_IMAGE_PATH"
fi

if [[ -n "$CLEAN" ]]; then
	rm -rf "$TMPDIR"

	# If there was a qcow disk being made and this script
	# plumbed up the nbd, unplumb it.  Same if it is an iso.
	if [[ "$DISK" =~ "qcow" ]]; then
		qemu-nbd --disconnect "$DEVICE"
		./sparsify-image.sh -D "$DISK"
	elif [[ "$DISK" =~ ".iso" ]]; then
		losetup -d "$DEVICE"
	fi
fi

popd
